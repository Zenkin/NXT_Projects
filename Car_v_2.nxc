#define RAD_WHEEL 0.028
#define BASE 0.153
#define DEG2RAD PI/180
#define LEFT OUT_C
#define RIGHT OUT_B
#define CRS 30
#define CLS 30

int RIGHT_SENSOR, LEFT_SENSOR, R_DELTA, L_DELTA, DELTA, NEED_DIST;
int rotA, rotB, pwm_left, pwm_right;
int base_speed = 50;
float bearing, relative_bearing, path, prev_path = 0, deltha_path;
float x_coord = 0, y_coord = 0, azimuth, control,delta_x, delta_y;
float x_ref = 1, y_ref = 1; //êîîðäèíàòû òî÷êè íàçíà÷åíèÿ
float k = 20, error = 0.05;
bool FLAG = false;

void CheckSensor(void);
void CheckRot(void);
void DistanceTraveled(void);
void LionInThePath(void);
void CoastIsClear(void);

task main(void)
{
     Wait(50);
     while (true) 
     {
          CheckSensor();
          CheckRot();
          DistanceTraveled();
          
          //îïðåäåëÿåì ðàññòîÿíèå äî îáúåêòà
          if (RIGHT_SENSOR < CRS)
          {
               FLAG = true; //âèäèì ïðåïÿòñòâèå
               R_DELTA = abs(CRS - RIGHT_SENSOR);
          }
          if (LEFT_SENSOR < CLS)
          {
               FLAG = true; //âèäèì ïðåïÿòñòâèå
               L_DELTA = abs(CLS - LEFT_SENSOR);
          }
          
          if (FLAG)
          {
               //îáúåçä
               LionInThePath();
          }
          else
          {
               CoastIsClear();
          }
          
          FLAG = false;
          if((abs(x_ref - x_coord)<error)&(abs(y_ref - y_coord)<error))
          {
               break; //âûõîä ïðè äîñòèæåíèè îáëàñòè òî÷êè
          }
     }
}

void CheckSensor(void)
{
     //ñíÿòèå ïîêàçàíèé ñ ñåíñîðîâ
     RIGHT_SENSOR = SensorUS(S1);
     LEFT_SENSOR = SensorUS(S2);
}

void CheckRot(void)
{
     //ñíÿòèå ïîêàçàíèé ñ ýíêîäåðîâ
     rotA = MotorRotationCount(LEFT);
     rotB = MotorRotationCount(RIGHT);
}

void DistanceTraveled(void)
{
     //ðàñ÷åò ïóòè ïðîéäåííîãî öåíòðîì ðîáîòà
     path = (rotA+rotB)*DEG2RAD*RAD_WHEEL/2;
     
     //ïóòü ïðîéäåííûé çà îäèí öèêë ïðîãðàììû
     deltha_path = path - prev_path;
     //ñîõðàíåíèå ïðåäûäóùåãî çíà÷åíèÿ äëèíû ïóòè
     prev_path = path;
     
     //âû÷èñëåíèå êîîðäèíàòû X è Y
     x_coord = x_coord + deltha_path * cos(bearing);
     y_coord = y_coord + deltha_path * sin(bearing);
     
     //âû÷èñëåíèå îòêëîíåíèÿ ïî X è Y
     delta_x = x_ref - x_coord;
     delta_y = y_ref - y_coord;
}

void LionInThePath(void)
{
     DELTA = R_DELTA - L_DELTA;
     control = sign(DELTA) * (NEED_DIST - (RIGHT_SENSOR + LEFT_SENSOR)/4);
     pwm_right =  base_speed - control;
     pwm_left =  base_speed + control;
}

void CoastIsClear(void)
{
     //ðàñ÷¸ò óãëà ïîâîðîòà
     bearing = (rotA-rotB)*DEG2RAD*RAD_WHEEL/BASE;

     //ðàñ÷åò ïåëåíãà
     azimuth = atan2(delta_y, delta_x);
     
     //ðàñ÷åò îòíîñèòåëüíîãî êóðñîâîãî óãëà
     relative_bearing = azimuth - bearing;
     
     //ðàçâîðîò ïî êðàò÷àéøåìó óãëó
     if (abs(relative_bearing) > PI) relative_bearing = relative_bearing - sign(relative_bearing) * 2 * PI;
     
     //ðàñ÷åò óïðàâëÿþùåãî âîçäåéñòâèÿ
     control = k * relative_bearing ;
     
     //ïðåîáðàçîâàíèå óïðàâëåíèÿ èç float â integer
     pwm_left =  base_speed + control;
     pwm_right =  base_speed - control;
     
     //íàñûùåíèå óïðàâëÿþùåãî âîçäåéñòâèÿ
     if (abs(pwm_left) > 100) pwm_left = sign(pwm_left)*100;
     if (abs(pwm_right) > 100) pwm_right = sign(pwm_right)*100;
     
     //ïîäà÷à óïðàâëåíèÿ
     OnFwd(LEFT, pwm_left);
     OnFwd(RIGHT, pwm_right);
}

