#define RAD_WHEEL 0.028
#define BASE 0.153
#define DEG2RAD PI/180
#define LEFT OUT_C
#define RIGHT OUT_B

int RIGHT_SENSOR, LEFT_SENSOR;

void ChekSensor(void);

task main(void)
{
     int rotA, rotB, pwm_left, pwm_right;
     int base_speed = 50;
     float bearing, relative_bearing, path, prev_path = 0, deltha_path;
     float x_coord = 0, y_coord = 0, azimuth, control,delta_x, delta_y;
     float x_ref = 1, y_ref = 1; //координаты точки назначения
     float k = 20, error = 0.05;
     Wait(50);

     while (true)
     {
          //снятие показаний с энкодеров
          rotA = MotorRotationCount(LEFT);
          rotB = MotorRotationCount(RIGHT);

          //расчет пути пройденного центром робота и угла его поворота
          path = (rotA+rotB)*DEG2RAD*RAD_WHEEL/2;
          bearing = (rotA-rotB)*DEG2RAD*RAD_WHEEL/BASE;

          //путь пройденный за один цикл программы
          deltha_path = path - prev_path;
          //сохранение предыдущего значения длины пути
          prev_path = path;

          //вычисление координаты X и Y
          x_coord = x_coord + deltha_path * cos(bearing);
          y_coord = y_coord + deltha_path * sin(bearing);
          //вычисление отклонения по X и Y
          delta_x = x_ref - x_coord;
          delta_y = y_ref - y_coord;

          azimuth = atan2(delta_y, delta_x); //расчет пеленга
          relative_bearing = azimuth - bearing; //расчет относительного курсового угла
          if (abs(relative_bearing) > PI) relative_bearing = relative_bearing - sign(relative_bearing) * 2 * PI;
          //разворот по кратчайшему углу

          control = k * relative_bearing ; //расчет управляющего воздействия
          pwm_left =  base_speed + control; //преобразование управления из float в integer
          pwm_right =  base_speed - control; //преобразование управления из float в integer
          if (abs(pwm_left) > 100) pwm_left = sign(pwm_left)*100; //насыщение управляющего воздействия
          if (abs(pwm_right) > 100) pwm_right = sign(pwm_right)*100; //насыщение управляющего воздействия
          OnFwd(LEFT, pwm_left); //подача управления
          OnFwd(RIGHT, pwm_right); //подача управления

          if((abs(x_ref - x_coord)<error)&(abs(y_ref - y_coord)<error))
          {
               break; //выход при достижении области точки
          }
     }
}

void ChekSensor(void)
{
     RIGHT_SENSOR = SensorUS(S1);
     LEFT_SENSOR = SensorUS(S2);
}
